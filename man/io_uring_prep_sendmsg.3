.\" Copyright (C) 2022 Jens Axboe <axboe@kernel.dk>
.\"
.\" SPDX-License-Identifier: LGPL-2.0-or-later
.\"
.TH io_uring_prep_sendmsg 3 "March 12, 2022" "liburing-2.2" "liburing Manual"
.SH NAME
io_uring_prep_sendmsg \- prepare a sendmsg request
.SH SYNOPSIS
.nf
.B #include <sys/types.h>
.B #include <sys/socket.h>
.B #include <liburing.h>
.PP
.BI "void io_uring_prep_sendmsg(struct io_uring_sqe *" sqe ","
.BI "                           int " fd ","
.BI "                           const struct msghdr *" msg ","
.BI "                           unsigned " flags ");"
.PP
.BI "void io_uring_prep_sendmsg_zc(struct io_uring_sqe *" sqe ","
.BI "                              int " fd ","
.BI "                              const struct msghdr *" msg ","
.BI "                              unsigned " flags ");"
.PP
.BI "void io_uring_prep_sendmsg_multishot(struct io_uring_sqe *" sqe ","
.BI "                                     int " fd ","
.BI "                                     const struct msghdr *" msg ","
.BI "                                     unsigned " flags ");"
.fi
.SH DESCRIPTION
.PP
The
.BR io_uring_prep_sendmsg (3)
function prepares a sendmsg request. The submission queue entry
.I sqe
is setup to use the file descriptor
.I fd
to start sending the data indicated by
.I msg
with the
.BR sendmsg (2)
defined flags in the
.I flags
argument.

The
.BR io_uring_prep_sendmsg_zc (3)
accepts the same parameters as 
.BR io_uring_prep_sendmsg (3)
but prepares a zerocopy sendmsg request.

.BR io_uring_prep_sendmsg (3)
may be used with provided buffers, where rather than pass a buffer in directly
with the request,
.B IOSQE_BUFFER_SELECT
is set in the SQE
.I flags
field, and additionally a buffer group ID is set in the SQE
.I buf_group
field. By using provided buffers with send requests, the application can
prevent any kind of reordering of the outgoing data which can otherwise
occur if the application has more than one send request inflight for a single
socket. This provides better pipelining of data, where previously the app
needed to manually serialize sends.

The multishot version allows the application to issue a single send request,
with a buffer group ID given in the SQE
.I buf_group
field, which keeps sending from that buffer group until it runs out of buffers.
As with any other request using provided buffers,
.B IOSQE_BUFFER_SELECT
must also be set in the SQE
.I flags
before submission. A CQE is posted for each send. As with receive multishot, an
application should expect further completions from this SQE as long as the
.B IORING_CQE_F_MORE
flag is set in the CQE
.I flags
field. Note that this can be used in conjunction with
.B MSG_WAITALL .
If
.B MSG_WAITALL
is set on a multishot request, the kernel will retry a short send and maintain
ordering within that send. If
.B MSG_WAITALL
is not set, then any short send will terminate the multishot request by nature
of the short IO completion not having
.B IORING_CQE_F_MORE
set in the CQE
.I flags
when posted. Send multishot, and send with provided buffers in general, are
available since kernel 6.9, and can be further identified by checking for the
.B IORING_FEAT_SEND_BUF_SELECT
flag returned in when using
.BR io_uring_init_queue_params (3)
to setup the ring.

Note that using
.B IOSQE_IO_LINK
with this request type requires the setting of
.B MSG_WAITALL
in the
.I flags
argument, as a short send isn't considered an error condition without
that being set.

This function prepares an async
.BR sendmsg (2)
request. See that man page for details.

.SH RETURN VALUE
None
.SH ERRORS
The CQE
.I res
field will contain the result of the operation. See the related man page for
details on possible values. Note that where synchronous system calls will return
.B -1
on failure and set
.I errno
to the actual error value, io_uring never uses
.IR errno .
Instead it returns the negated
.I errno
directly in the CQE
.I res
field.
.SH NOTES
As with any request that passes in data in a struct, that data must remain
valid until the request has been successfully submitted. It need not remain
valid until completion. Once a request has been submitted, the in-kernel
state is stable. Very early kernels (5.4 and earlier) required state to be
stable until the completion occurred. Applications can test for this
behavior by inspecting the
.B IORING_FEAT_SUBMIT_STABLE
flag passed back from
.BR io_uring_queue_init_params (3).
.SH SEE ALSO
.BR io_uring_get_sqe (3),
.BR io_uring_submit (3),
.BR io_uring_buf_ring_init (3),
.BR io_uring_buf_ring_add (3),
.BR sendmsg (2)
